# backend/routers/insights_router.py — v1.0
"""
AION Analytics — Insights Router (Nightly + Multi-Layer + UI Feed)

Delivers all Top-50 insight boards generated by:
    backend/services/insights_builder.py

Boards (JSON files under PATHS["insights"]):
    • top50_1w.json
    • top50_2w.json
    • top50_4w.json
    • top50_52w.json
    • top50_social_heat.json
    • top50_news_novelty.json

PLUS:
    • /api/insights/predictions/latest  → full UI-optimized prediction feed
      (from logs/nightly/predictions/latest_predictions.json)

Features:
    • API selection: board=1w,2w,4w,52w,social,news
    • Filtering: sector=..., minConfidence=...
    • Sorted by score (default)
    • Fallback to Rolling if JSON missing
"""

from __future__ import annotations

import json
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

from fastapi import APIRouter, Query

from backend.core.config import PATHS, TIMEZONE
from backend.core.data_pipeline import _read_rolling, log
from backend.services.insights_builder import build_daily_insights

router = APIRouter(prefix="/api/insights", tags=["Insights"])


# ---------------------------------------------------------------------
# FILE MAPS / PATHS
# ---------------------------------------------------------------------

BOARD_MAP: Dict[str, str] = {
    "1w": "top50_1w.json",
    "2w": "top50_2w.json",
    "4w": "top50_4w.json",
    "52w": "top50_52w.json",
    "social": "top50_social_heat.json",
    "news": "top50_news_novelty.json",
}

INSIGHTS_DIR: Path = PATHS.get("insights", PATHS.get("root", Path(".")) / "insights")

PRED_DIR: Path = PATHS.get(
    "nightly_predictions",
    PATHS["root"] / "logs" / "nightly" / "predictions",
)
LATEST_PRED_FILE: Path = PRED_DIR / "latest_predictions.json"


# ---------------------------------------------------------------------
# HELPERS
# ---------------------------------------------------------------------

def _load_json(path: Path) -> Optional[Dict[str, Any]]:
    """Safely load a JSON file; return None on error."""
    if not path.exists():
        return None
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except Exception as e:
        log(f"[insights_router] ⚠️ Failed to read {path}: {e}")
        return None


def _load_board(file_name: str) -> Optional[Dict[str, Any]]:
    """Load a board JSON by filename from INSIGHTS_DIR."""
    return _load_json(INSIGHTS_DIR / file_name)


def _norm_sector(s: Optional[str]) -> Optional[str]:
    if s is None:
        return None
    s2 = str(s).strip().upper()
    return s2 if s2 else None


def _filter_items(
    items: List[Dict[str, Any]],
    sector: Optional[str],
    min_conf: Optional[float],
) -> List[Dict[str, Any]]:
    """Apply sector + minConfidence filters to an items list."""
    sec = _norm_sector(sector)

    out: List[Dict[str, Any]] = []
    for row in items:
        if sec:
            rsec = row.get("sector")
            rsec = _norm_sector(rsec) if rsec is not None else None
            if rsec != sec:
                continue

        if min_conf is not None:
            conf = row.get("confidence")
            if conf is None:
                # some rows use avg_confidence (sector perf etc.)
                conf = row.get("avg_confidence", 0.0)
            try:
                conf_val = float(conf or 0.0)
            except Exception:
                conf_val = 0.0
            if conf_val < min_conf:
                continue

        out.append(row)
    return out


# ---------------------------------------------------------------------
# NEW ROUTE — UI-Optimized Prediction Feed
# ---------------------------------------------------------------------

@router.get("/predictions/latest")
async def get_latest_prediction_feed():
    """
    Returns the latest UI-ready prediction feed produced by prediction_logger.py.
    """
    if not LATEST_PRED_FILE.exists():
        return {
            "status": "missing",
            "error": "latest_predictions.json not found. Run prediction_logger / nightly job.",
            "path": str(LATEST_PRED_FILE),
        }

    data = _load_json(LATEST_PRED_FILE)
    if not data:
        return {
            "status": "error",
            "error": "Failed to parse latest_predictions.json",
            "path": str(LATEST_PRED_FILE),
        }

    return data


# ---------------------------------------------------------------------
# MAIN ROUTE — Top-N Insight Boards
# ---------------------------------------------------------------------

@router.get("/")
async def get_insights(
    board: str = Query(
        "1w",
        description="Insight board: 1w | 2w | 4w | 52w | social | news",
    ),
    limit: int = Query(50, description="Number of items to return."),
    sector: Optional[str] = Query(None, description="Filter by sector."),
    minConfidence: Optional[float] = Query(
        None, description="Filter by minimum confidence (0–1)."
    ),
):
    """
    Returns a Top-N insight board generated by nightly insights_builder.

    Normal path:
        • Reads top50_*.json from INSIGHTS_DIR
        • Applies filters
        • Returns items + metadata

    If board JSON missing:
        • Rebuilds insights once via build_daily_insights()
        • Tries to reload file

    If still missing:
        • Fallback to a simple Rolling-based ML board (1d horizon)
    """
    board_key = board.lower()
    if board_key not in BOARD_MAP:
        return {
            "error": f"Invalid board '{board}'",
            "allowed": list(BOARD_MAP.keys()),
        }

    file_name = BOARD_MAP[board_key]

    # 1) Try load existing board
    js = _load_board(file_name)

    # 2) Missing → rebuild once
    if js is None:
        log(f"[insights_router] ⚠️ Board {file_name} missing → rebuilding insights.")
        try:
            build_daily_insights(limit=limit)
            js = _load_board(file_name)
        except Exception as e:
            log(f"[insights_router] ❌ Rebuild failed: {e}")
            js = None

    # 3) If still missing → Rolling fallback (never fails)
    if js is None:
        log(f"[insights_router] ⚠️ Fallback to Rolling for board {board_key}")
        rolling = _read_rolling() or {}

        sec = _norm_sector(sector)

        rows: List[Dict[str, Any]] = []
        for sym, node in rolling.items():
            if sym.startswith("_"):
                continue

            preds = node.get("predictions") or {}
            if not isinstance(preds, dict):
                continue

            h1 = preds.get("1d", {}) if isinstance(preds.get("1d"), dict) else {}
            ml_score = h1.get("score")
            confidence = h1.get("confidence")

            row = {
                "symbol": sym.upper(),
                "name": node.get("name"),
                "sector": _norm_sector(node.get("sector")),
                "ml_score": ml_score,
                "confidence": confidence,
            }

            if sec and row["sector"] != sec:
                continue

            if minConfidence is not None:
                try:
                    cval = float(confidence or 0.0)
                except Exception:
                    cval = 0.0
                if cval < minConfidence:
                    continue

            rows.append(row)

        rows.sort(key=lambda x: x.get("ml_score", 0.0) or 0.0, reverse=True)
        top_rows = rows[:limit]

        return {
            "timestamp": datetime.now(TIMEZONE).isoformat(),
            "board": board_key,
            "count": len(top_rows),
            "items": top_rows,
            "source": "rolling_fallback",
        }

    # 4) Normal success path
    items = js.get("items") or []
    if not isinstance(items, list):
        items = []

    items = _filter_items(items, sector, minConfidence)
    items = items[:limit]

    return {
        "timestamp": js.get("generated_at"),
        "board": board_key,
        "count": len(items),
        "items": items,
        "source": "insights_files",
    }
